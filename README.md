# 🔗 참고 링크

## 1. Java

- [자바가 지원하는 타입은 4가지](https://www.devkuma.com/docs/java/data-type/): 이펙티브 자바 4쪽 내용이다. 자바가 지원하는 타입은 `인터페이스 (interface)`, `클래스 (class)`, `배열 (array)`, `기본 타입 (primitive type)`까지 총 4가지다. `애너테이션 (annotation)`은 인터페이스의 일종이며 `열거 타입 (enum)`은 클래스의 일종이다. 4가지 타입 중 처음 3가지는 `참조 타입 (reference type)`이라 한다. 즉, 클래스의 인스턴스와 배열은 객체인 반면 기본 타입 값은 그렇지 않다. 클래스의 `멤버`로는 `필드 (field)`, `메서드 (mehotd)`, `멤버 클래스`, `멤버 인터페이스`가 있다. 메서드 signature는 메서드 이름과 입력 파라미터의 타입들로 이루어진다. 메서드 signature에는 반환 타입이 포함되지 않음에 주의하자.

- [`shutdownNow()` 메서드를 호출해도 `InterruptedException`이 발생하지 않는 경우](https://stackoverflow.com/questions/70433737/threadpoolexecutor-shutdownnow-not-throwing-interruptedexception-in-thread): `shutdownNow()` 메서드는 `Thread.interrupt()`를 이용하는데 `readLine()` 메서드와 같은 경우 인터럽트에 응답하지 않아서 원하는 대로 동작하지 않을 수 있다.

- [`AutoCloseable`을 구현하고 있는 `ExecutorService`](https://stackoverflow.com/questions/41393417/why-does-the-executorservice-interface-not-implement-autocloseable): 자바 19부터 `ExecutorService`는 `AutoCloseable`을 구현하고 있기 때문에 `try-with-resources` 구문을 활용할 수 있다. `finally`에 `shutdown()`을 하고 있다고 볼 수 있으므로 별도로 `shutdown()` 메서드를 아래쪽에 또 호출하고 있는 것은 아닌지 주의해야 한다.

- [자바의 데이터 전달 방식은 `Pass by Value`](https://mangkyu.tistory.com/107): 자바는 primitive type이든 reference type이든 `Pass by Value`로 데이터를 전달한다. primitive type은 쉽게 이해할 수 있지만 reference type도 `Pass by Value`로 동작하는 것이 맞는지 헷갈릴 수 있다. 자바에서 객체를 전달할 때 해당 객체가 저장된 주소가 복사되어 전달된다. 따라서 해당 주소를 바탕으로 필드에 접근하는 것은 가능하지만 그 객체 자체를 변경하는 것은 원본의 데이터에 영향을 주지 않는다. `Pass by Reference`는 주소를 전달하여 원본에 대한 alias를 구성함으로써 원본 그 자체에도 영향을 주는 것을 의미한다.

- [`@FunctionalInterface` 애너테이션](https://docs.oracle.com/javase/8/docs/api/java/lang/FunctionalInterface.html): 자바 API를 살펴보다 보면 functional interface에 `@FunctionalInterface` 애너테이션이 붙어있는 것을 볼 수 있다. 해당 애너테이션은 말 그대로 functional interface임을 가리키는 애너테이션이다. @FunctionalInterface로 인터페이스를 선언했지만 abstract method가 2개 이상이라면 컴파일 에러가 발생한다. 여기서 abstract method의 개수에는 부모 인터페이스의 abstract method도 포함된다. static, default method는 몇 개가 있든 상관없다. 한 가지 흥미로운 점은 Comparator를 살펴보면 abstract method가 `compare(T o1, T o2)`, `equals(Object obj)`로 2개임에도 불구하고 @FunctionalInterface 애너테이션이 붙어있다는 것이다. 오라클 공식문서를 살펴보면 Object의 public method는 abstract method 개수에 포함되지 않는다고 한다. 이유는 어떤 인터페이스의 구현체든 Object 클래스를 상속하고 있을 것이고, 따라서 Object 클래스의 `equals(Object obj)`로부터 구현부를 상속받기 때문이다. 결국 functional interface에 Object의 public method를 둔다 하더라도 해당 인터페이스의 구현체는 Object를 상속하게 될 것이므로, 구현체 상태에서는 확정으로 abstract method가 아니기 때문에 abstract method 개수에 포함되지 않는 것이다. 처음에는 인터페이스도 Object 클래스를 상속하므로 인터페이스 자체만으로도 구현부를 가지고 있기 때문이라 착각했는데 오개념이었다. 인터페이스는 Object 클래스를 상속하지 않는다. 하지만 인터페이스의 구현체를 만들면 반드시 Object 클래스를 상속하게 된다. 그렇다면 여기서 하나 드는 의문이 있다. 굳이 Comparator에 `equals(Obejct obj)`를 명시적으로 적을 필요가 있을까? Javadoc이나 [스택오버플로우](https://stackoverflow.com/questions/11013850/why-does-comparator-declare-equals) 설명을 봐도 잘 모르겠다. 심심할 때 생각해보자.

- [람다 형식 추론](https://seoarc.tistory.com/86): 모던 자바 인 액션 108쪽 내용이다. 람다로 인터페이스의 인스턴스를 만들 수 있었다. 그런데 람다 표현식 자체에는 람다가 어떤 functional interface를 구현하는지의 정보가 포함되어 있지 않다. 대신 람다가 사용되는 context를 이용해서 람다의 형식을 추론한다. 어떤 context에서 기대되는 람다 표현식의 형태를 `대상 형식 (target type)`이라고 부른다. 여기서 context란 람다가 전달될 메서드 파라미터나 람다가 할당되는 변수 등을 의미한다. 대상 형식이라는 특징 덕분에 같은 람다 표현식이더라도 호환되는 추상 메서드를 가진 다른 functional interface의 인스턴스로 사용할 수 있다. 예를 들어 `() -> 42` 람다식은 `Callable<Integer>`, `PrivilegedAction<Integer>` 둘 다에 대해 인스턴스를 만들 때 사용할 수 있다. 추가로 람다의 바디에 일반 표현식이 있으면 void를 반환하는 function descriptor와 호환된다. 예를 들어 list.add(obj)는 boolean을 반환하지만 `Consumer<T>: t -> void`에서도 사용할 수 있다. 마지막으로 메서드가 오버로딩 되어있는데 `execute(Runnable runnable)`, `execute(Action<T> action)`처럼 function descriptor가 같을 수 있다. `execute(() -> {})`라는 람다식을 사용할 경우 둘 중 누구를 가리키는지 명확하지 않다. 이런 경우 어떤 메서드의 signature가 사용되어야 하는지를 명시적으로 구분하기 위해 람다를 캐스팅해야 한다. 예시에서는 `execute((Action) () -> {})`와 같이 사용하면 된다.

- [람다 캡처링 (capturing lambda)](https://vagabond95.me/posts/lambda-with-final/): 모던 자바 인 액션 112쪽 내용이다. `람다 캡처링`은 익명 함수처럼 람다 표현식에서 `자유 변수 (free variable)`을 활용하는 동작을 말한다. 여기서 자유 변수는 파라미터로 넘겨진 변수가 아닌 외부에서 정의된 변수를 의미한다. 그런데 활용할 수 있는 자유 변수에는 제약이 있다. 우선 자유 변수 중 인스턴스 변수와 정적 변수는 자유롭게 캡처, 즉 람다 표현식의 바디에서 참조할 수 있다. 그러나 자유 변수 중 지역 변수는 `final` 혹은 `effectively final`한 경우에만 캡처할 수 있다. 여기서 지역 변수가 람다 표현식 내에서 `effectively final`은 syntactic sugar의 일종으로 `final` 키워드가 붙지 않은 변수지만 초기화 이후 값이 한 번도 변경되지 않은 것을 의미한다. 그렇다면 지역 변수에는 왜 `final` 혹은 `effectively final`이라는 제약이 있을까? 그 이유는 다음과 같다. 지역 변수는 스택 영역에 생성된다. 따라서 지역 변수가 선언된 block이 끝나면 스택에서 제거된다. 메서드 내 지역 변수를 참조하는 람다 표현식을 반환하는 메서드가 있을 경우, 메서드 block이 끝나면 지역 변수가 스택에서 제거되므로 추후 람다 표현식이 수행될 때 참조할 수 없다. 지역 변수를 관리하는 스레드와 람다 표현식이 실행되는 스레드가 다른 경우도 마찬가지다. 그래서 람다 표현식에서 사용하는 지역 변수는 `Pass by Value`로 복사본을 전달받아 사용된다. 여기까지 숙지했으면 이유를 이해할 수 있다. 지역 변수를 제어하는 스레드 A와 람다 표현식이 수행되는 스레드 B가 다를 때, 스레드 B에서 참조하는 지역 변수가 가장 최신 값으로 복사되어 전달된 건지 확신할 수가 없다. 지역 변수는 스레드 A의 스택 영역에 존재하기 때문에 다른 스레드에서 접근이 불가능하다. 이 말은 지역 변수를 스레드 간에 동기화시키는 것은 불가능하다는 것이다. 결국 확신할 수 없는 코드는 의미가 없으므로 자유 변수에 제약을 붙여 최신 값임을 보장한 것이다. 한편, 인스턴스 변수는 힙 영역에 저장되고 정적 변수는 메서드 영역에 저장되는데 두 영역 모두 스레드 간 공유하는 영역이기 때문에 제약이 없다. 물론 멀티 스레드 환경일 경우 필요하다면 동기화하는 작업은 있어야할 것이다. 참고로 자바에서 모든 데이터 전달 방식은 `Pass by Value`임을 명심하자. 위 설명을 보고 지역 변수에 한해서만 `Pass by Value`라고 이해하면 안 된다.

- [공변성 (covariance), 반공변성 (contravariance), 불공변성 (invariance)](https://learn.microsoft.com/ko-kr/dotnet/standard/generics/covariance-and-contravariance): `변성 (variance)`은 타입의 상속 계층 관계에서 서로 다른 타입 간에 어떤 관계가 있는지 나타내는 지표다. 우선 변성 개념이 왜 필요할까? 많은 프로그래밍 언어들의 타입 시스템은 서브타이핑 (subtyping) 개념을 지원한다. 리스코프 치환 원칙을 생각해보면 된다. 여기서 변성은 복잡한 타입들 간 서브타이핑이 등장했을 때 어떻게 동작할지에 관한 것이다. 예를 들어 `List<Child>`와 `List<Parent>` 사이의 관계, `Child`를 반환하는 함수와 `Parent`를 반환하는 함수 사이의 관계 등에서 말이다. 프로그래밍 언어를 설계할 때 배열, 상속, 제네릭 등과 같은 언어 기능에 대한 typing rule을 정할 때 변성을 고려한다. 이제 변성과 관련한 3가지 성질을 알아보자. 우선 공변성은 타입의 순서가 보존되는 경우다. 본래 지정된 타입보다 더 많이 파생된 타입을 사용할 수 있다. `Child`와 `Parent`의 관계처럼 `T<Child>`가 `T<Parent>`의 서브타입으로 간주되는 것이다. 다음으로 반공변성은 타입의 순서가 반대로 보존되는 경우다. 본래 지정된 타입보다 더 제네릭한 (덜 파생적인) 타입을 사용할 수 있다. `Child`와 `Parent`의 관계와는 반대로 `T<Parent>`가 `T<Child>`의 서브타입으로 간주되는 것이다. 마지막으로 반공변성은 타입 변환이 불가능한 경우다. 공변성을 가지지도, 반공변성을 가지지도 않은 것이다. 이제 자바 관점으로 들어가보자. 자바에서 배열은 공변성을 가지고 있지만 제네릭은 불공변성을 가지고 있다. 흔히 배열과 제네릭을 같이 비교하는 것이 둘이 대조되는 성질을 가지고 있기 때문이다. 추가적으로 반공변성을 처음에 공부할 때 이 성질이 가능한 건지, 실제로 쓰이긴 하는 건지 의문이 들었는데 와일드카드를 공부하고 깨닫게 되었다. 와일드카드는 설명이 길어 따로 설명하겠다.

- [배열은 공변이고 제네릭은 불공변인 이유](https://stackoverflow.com/questions/18666710/why-are-arrays-covariant-but-generics-are-invariant): 근본적으로 자바에서 배열은 왜 공변성을 가지고 제네릭은 불공변성을 가질까? 공변성을 가지면 다형성을 활용할 수 있다는 장점이 있지만 타입 안정성을 해칠 수 있다는 단점이 있다. 초기에는 제네릭에 대한 개념이 없었고 타입 안정성에 대한 단점보다는 다형성을 통해 얻는 장점이 더 크다고 판단했던 것 같다. 추후 제네릭이 등장할 때는 타입 안정성을 더 신경써서 불공변하게 설계한 것으로 보인다. 이전 버전과의 호환성을 위해 제네릭은 배열과 달리 런타임 시에 타입 소거 (type erasure)가 발생하는 것도 이유에 포함되는 것 같다. 공변하는 배열과 공변하는 제네릭이 있다고 가정했을 때 타입 안정성에 대한 부작용은 배열이 타입 소거가 발생하는 제네릭이 더 크기 때문이다. 여기에 더해 와일드카드를 활용하면 제네릭의 불공변성으로 인한 단점을 보완할 수 있으므로 불공변하게 설계한 것은 적절했다고 생각한다. 지금까지의 설명을 보면 그럼 요즘 자바가 개발되었다면 배열도 불공변하게 설계되었을까 하는 의문이 들 수 있다. 이에 대해 나는 그렇다고 생각한다. 실제로 나중에 나온 코틀린은 배열도 불공변이라고 알고 있다. 제네릭과 와일드카드를 활용하면 타입 안정성을 보장하면서도 다형성을 통해 유연하게 설계할 수 있다.

- [실체화 (reifiable) 타입과 실체화 불가 (non-reifiable) 타입](https://inpa.tistory.com/entry/JAVA-%E2%98%95-%EC%A0%9C%EB%84%A4%EB%A6%AD-%ED%83%80%EC%9E%85-%EC%86%8C%EA%B1%B0-%EC%BB%B4%ED%8C%8C%EC%9D%BC-%EA%B3%BC%EC%A0%95-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0): `실체화 타입`이란 컴파일 단계에서 타입 소거에 의해 타입 정보가 지워지지 않는 타입을 말한다. 일반적인 타입을 생각하면 된다. 원시 타입, 일반 클래스와 인터페이스 타입, 비한정적 와일드카드가 사용된 타입이 그 예다. 비한정적 와일드카드는 애초에 타입 정보를 전혀 명시하지 않았으므로, 컴파일 단계에서 잃을 정보가 없고 따라서 실체화 타입으로 간주할 수 있다. 컴파일 단계에서 `Object`로 변환된다. `실체화 불가 타입`이란 컴파일 단계에서 타입 소거에 의해 타입 정보가 제거되는 타입을 말한다. 제네릭 타입 파라미터를 생각하면 된다. `List<T>`, `List<Number>`, `List<T extends Number>`, `List<? extends Number>`, `List<? super Number>`이 그 예다.

- [제네릭과 와일드카드](https://stackoverflow.com/questions/176446/how-can-elements-be-added-to-a-wildcard-generic-collection): 자바에서 와일드카드를 활용하면 제네릭에 다형성을 적용할 수 있다. 보통 이를 `사용처 변성 (use-site variance)`라고 한다. 사용처 변성과 대응되는 개념으로는 `선언처 변성 (declaration-site variance)`이 있는데, 스칼라가 대표적인 선언처 변성 언어라고 한다. 본론으로 돌아와서 와일드카드에는 상한 경계를 의미하는 `<? extends U>`, 하한 경계를 의미하는 `<? super U>`, 비경계를 의미하는 `<?>` (`<? extends Object>`의 줄임 표현)가 있다. 어떤 경우에 extends를 쓰고 super를 쓰는지는 추후 이펙티브 자바 공부를 하면서 보완하겠다.

- [생성자 대신 정적 팩터리 메서드 고려](https://github.com/Meet-Coder-Study/book-effective-java?tab=readme-ov-file): 이펙티브 자바 8쪽 내용이다. 클래스는 클라이언트에 public 생성자 대신 (혹은 생성자와 함께) 정적 팩터리 메서드를 제공할 수 있다. 정적 팩터리 메서드 사용에는 장단점이 있다. 우선 `장점`이다. `첫 번째`, 이름을 가질 수 있다. 반환될 객체의 특성을 직관적으로 묘사할 수 있고, 여러 생성자의 signature가 중복되는 경우 하나밖에 사용하지 못하는 단점을 피할 수 있다. `두 번째`, 호출될 때마다 객체를 새로 생성하지는 않아도 된다. 객체를 통제하여 클래스를 싱글턴으로 만들 수도, 인스턴스화 불가로 만들 수도 있다. `세 번째`, 반환 타입의 서브타입 객체를 반환할 수 있는 능력이 있다. 생성자는 해당 클래스의 객체만 반환할 수 있다. 그런데 정적 팩터리 메서드는 호환 가능한 다른 클래스의 객체를 반환할 수 있다. `네 번째`, 세 번째와 이어지는데 입력 파라미터에 따라 매번 다른 클래스의 객체를 반환할 수 있다. 참고로 자바 8 이전에는 인터페이스에 정적 메서드를 선언할 수 없었다. 그래서 `Type`인 인터페이스를 반환하는 정적 메서드가 필요하면, `Types`라는 인스턴스화 불가인 `동반 클래스 (companion class)`를 만들어 그 안에 정의하는 것이 관례였다. 이에 대한 대표적인 예시가 수정 불가나 동기화 등의 기능을 덧붙인 유틸리티 구현체를 제공하는 `Collections`다. `다섯 번째`, 정적 팩터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다. 이건 `서비스 제공자 프레임워크 (service provider framework)` 항목으로 따로 빼서 설명하겠다. 다음은 `단점`이다. `첫 번째`, 상속을 하려면 public이나 protected 생성자가 필요하니 정적 팩터리 메서드만 제공하면 하위 클래스를 만들 수 없다. 그런데 이 제약은 상속보다 컴포지션을 사용하도록 유도하고 불변 타입으로 만들려면 이 제약을 지켜야 한다는 점에서 장점으로 활용할 수도 있다. `두 번째`, 정적 팩터리 메서드는 프로그래머가 찾기 어렵다. 생성자처럼 API 설명에 명확히 드러나지 않아 사용자는 정적 팩터리 메서드 방식 클래스를 인스턴스화할 방법을 알아내야 한다. 그래서 Javadoc을 이용해 API 문서를 쓰고 메서드 이름도 관례에 따라 지음으로써 문제를 완화해줘야 한다.

- [자바가 메모리를 할당하는 방법](https://tangoblog.tistory.com/m/14)

- [자바 제네릭 타입 소거](https://inpa.tistory.com/entry/JAVA-%E2%98%95-%EC%A0%9C%EB%84%A4%EB%A6%AD-%ED%83%80%EC%9E%85-%EC%86%8C%EA%B1%B0-%EC%BB%B4%ED%8C%8C%EC%9D%BC-%EA%B3%BC%EC%A0%95-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0)

- [제네릭에 참조 타입만 사용 가능한 이유]()

- [싱글턴 보증 방법](https://github.com/Meet-Coder-Study/book-effective-java?tab=readme-ov-file): 이펙티브 자바 23쪽 내용이다. 싱글턴을 만드는 방식은 보통 3가지가 있다. `첫 번째`, `private` 생성자와 `public static final` 필드를 이용한 방식이다. 장점으로는 간결하고 싱글턴임을 Javadoc에 드러낼 수 있다. 단점으로는 3가지가 있다. 단점 첫 번째, 싱글턴을 사용하는 클라이언트 테스트가 어려워진다. 해당 싱글턴이 외부 API와 연동을 하거나 무거운 연산을 요구하는 경우, 테스트할 때마다 해당 작업을 수행하는 것이 테스트에 어려움을 주는 것이다. 다만 인터페이스가 있는 경우 싱글턴 인스턴스를 `mock` 구현으로 대체할 수 있다. 단점 두 번째, 리플렉션을 사용하면 싱글턴이 깨질 수 있다. 권한이 있는 클라이언트는 리플렉션 API의 `getDeclaredConstructor()`로 private 생성자를 가져온 후 `accessibleObject.setAccessible(true)`를 수행하면 인스턴스를 생성할 수 있다. 여러 번 호출하면 각기 다른 인스턴스가 생성된다. 이를 방지하려면 별도로 boolean 변수를 두고 인스턴스가 생성된 적이 있는지 확인하는 로직을 추가하는 등의 작업이 필요하다. 단점 세 번째, 역직렬화할 때 싱글턴이 깨질 수 있다. 이를 방지하려면 `readResolve()` 메서드를 정의하여 기존에 생성된 인스턴스를 반환하도록 해야 한다. 구체적으로는 `역직렬화 공격`을 알아야 하는데 이건 따로 다루겠다. 두 번째, 세 번째 단점을 해결하려다 보면 간결하다는 장점이 퇴색된다. `두 번째`, `private` 생성자와 `정적 팩터리 메서드`를 이용한 방식이다. public static final을 사용하는 방법과 단점은 동일한데 장점이 몇 가지 더 있다. 첫 번째, 클라이언트 API를 변경하지 않고 동작을 바꿀 수 있다. 예를 들어 `getInstance()` 호출 코드에는 영향을 주지 않은 채로, 싱글턴 인스턴스를 반환하는 코드에서 매번 새로운 인스턴스를 반환하는 코드로 바꿀 수 있다. 두 번째, 정적 팩터리를 제네릭 싱글턴 팩토리로 만들 수 있다. 제네릭 싱글턴 팩터리를 이용하면 인스턴스는 동일하지만 원하는 타입의 인스턴스로 바꿔서 들고올 수 있다. 여기서 주의할 점은 동일한 인스턴스를 다른 타입으로 들고왔을 때 두 인스턴스의 `==` 비교는 불가능하고 `equals()`는 되는 것이다. 별도로 재정의하지 않는 이상 `equals()`는 내부적으로 `==`을 사용하기 때문에 왜 다른 건가 했는데 `equals()`는 인자로 받을 때 `Object` 타입으로 받아서 문제가 없는 것으로 보인다. 세 번째, 정적 팩터리 메서드 참조를 `Supplier`로 사용할 수 있다. `세 번째`, 열거 타입을 이용한 방식이다. 이 방법은 리플렉션과 역직렬화 문제로부터 자유롭다는 장점이 있다. 그래서 싱글턴을 만들 때 가장 권장되는 방식인데, 열거 타입은 상속이 불가능하다는 단점이 있다. 물론 인터페이스 구현은 가능하기 때문에 테스트에는 문제가 없다.

## 2. Algorithm

## 3. OS

## 4. Network

- [네트워크 성능 지표](https://aws.amazon.com/ko/compare/the-difference-between-throughput-and-latency/): 혼자 공부하는 네트워크 71쪽 내용이다. 컴퓨터 네트워크의 성능을 평가하는 데에는 `처리율 (throughput)`, `대역폭 (bandwidth)`, `지연시간 (latency)`, `패킷 손실 (packet loss)` 등 여러 가지 지표가 있다. `처리율`은 단위 시간당 네트워크를 통해 실제로 전송되는 정보량을 의미한다. 일반적으로 `bps (bit/s)`, `Mbps (Mbit/s)`, `Gbps (Gbit/s)` 단위로 표현한다. 때로는 초당 패킷 수를 표현하기 위해 `pps (p/s)` 단위를 사용하기도 한다. 처리율은 비교적 실시간성이 강조된 지표로, 특정 노드가 얼마만큼의 트래픽을 처리하는 중인지 판단하기 위해 사용되는 경우가 많다. `대역폭`이라는 용어는 신호 처리 영역에서의 정의와 네트워크 성능 측정 영역에서의 정의가 다소 다르다. 전자는 주파수의 범위를 의미하지만, 후자는 단위 시간 동안 통신 매체를 통해 송수신할 수 있는 최대 정보량을 의미한다. 처리율과 같이 `bps`, `Mbps`, `Gbps`를 단위로 사용한다. `지연시간`은 네트워크를 통해 데이터를 전송하는 데 걸리는 시간을 나타낸다. 일반적으로 지연시간은 패킷이 목적지에 도달하고 나서 그에 대한 응답이 출발지로 다시 돌아가기까지의 시간을 의미하는 `RTT (round trip time)`로 판단한다. RTT를 측정하는 방법 중 하나가 `ping` 관련 명령어다. `패킷 손실`은 송수신되는 패킷이 손실된 상황을 의미한다. 높은 트래픽으로 인해 노드가 순간적으로 처리해야 할 패킷이 너무 많아지거나 네트워크상에 예기치 못한 장애가 발생해서 패킷을 처리하지 못하면 패킷 손실이 발생할 수 있다. 일반적으로 패킷 손실은 전체 패킷 중 유실된 패킷을 백분위로 표현한 값을 사용한다. 패킷 손실 또한 `ping` 명령어로 확인할 수 있다.

- [이더넷](https://ko.wikipedia.org/wiki/%EC%9D%B4%EB%8D%94%EB%84%B7): 혼자 공부하는 네트워크 76쪽 내용이다. `이더넷 (Ethernet)`은 현대 LAN, 특히 유선 LAN 환경에서 가장 대중적으로 사용되는 기술이다. 물리 계층과 데이터 링크 계층에서 이더넷이라는 공통된 기술이 사용된다. 이더넷 관련 기술은 `IEEE 802.3`이라는 이름으로 표준화되었다. 이더넷 표준에 따라 통신 매체의 종류와 전송 속도가 달라질 수 있다. 일반적으로 이더넷 표준 규격에 따라 구현된 통신 매체를 지칭할 때는 통신 매체의 속도와 특성을 한눈에 파악할 수 있도록 `{전송 속도}{변조 타입}-{추가 특성}` 형태로 표기한다. `전송 속도 (data rate)`는 숫자만 표기되어 있으면 Mbps 속도, 숫자 뒤에 G가 붙는 경우 Gbps 속도를 나타낸다. `변조 타입 (modulation type)`은 간단하게 전송 방법이라고 생각하면 된다. 전송 방법은 이더넷 통신 매체의 경우 대부분 `BASE (BASEband)`를 사용한다. BASE 외에 `BROAD (BROADband)`, `PASS (PASSband)`도 존재한다. 추가 특성은 전송 가능한 최대 거리, 물리 계층 인코딩 방식, 통신 매체 종류 등이 명시된다. 이 중 가장 중요한 건 통신 매체 종류다. 추가 특성에 `C`, `T`, `S`, `L`이라는 글자가 있다면 각각 동축 케이블 (C), 트위스티드 페어 케이블 (T), 단파장 빛을 활용하는 광섬유 케이블 (S), 장파장 빛을 활용하는 광섬유 케이블 (L)을 의미한다. 지금까지 물리 계층과 관련된 설명이었다.

- [이더넷 프레임](http://www.ktword.co.kr/test/view/view.php?no=2965): 데이터 링크 계층의 이더넷 프레임에 대한 설명이다. 송신자 입장에서 이더넷 프레임은 상위 계층으로부터 받아들인 정보에 헤더와 트레일러를 추가하는 캡슐화 과정을 통해 만들어진다. 수신자 입장에서는 프레임의 헤더와 트레일러를 제거한 뒤 상위 계층으로 올려보내는 역캡슐화 과정을 거친다. 이더넷 프레임 헤더는 기본적으로 `프리앰블 (preamble)`, `수신지 MAC 주소`, `송신지 MAC 주소`, `타입/길이`로 구성되고, 페이로드는 `데이터`, 트레일러는 `FCS (frame check sequence)`로 구성된다. 프리앰블은 이더넷 프레임의 시작을 알리는 8바이트 (64비트) 크기의 정보다. 프리앰블의 처음 7바이트는 각각 `10101010` 값을 가지고, 마지막 바이트는 `10101011` 값을 가진다. 송수신기 간의 동기화를 위해 사용되는 정보인 것이다. MAC 주소는 네트워크 인터페이스마다 부여되는 6바이트 (48비트) 길이의 주소로, LAN 내의 수신지와 송신지를 특정할 수 있다. MAC 주소는 일반적으로 고유하고 변경되지 않는다. 보통 `NIC (Network Interface Controller)`이라는 장치가 네트워크 인터페이스 역할을 담당한다. 만약 한 컴퓨터에 NIC이 여러 개 있다면 MAC 주소도 여러 개 있을 수 있다. 참고로 MAC 주소는 변경이 가능한 경우도 있으며, 따라서 고유하지 않을 수도 있다. 타입/길이 필드에는 `타입 (type)` 혹은 `길이 (length)`가 올 수 있다. 필드에 명시된 크기가 1500 (0x05DC) 이하일 경우 이 필드는 프레임의 길이를 나타내는 데 사용되고, 1536 (0x0600) 이상일 경우에는 타입을 나타내는 데 사용된다. 데이터는 상위 계층에서 전달받거나 상위 계층으로 전달해야 하는 내용이다. 데이터 링크 계층에서 데이터는 네트워크 계층의 데이터와 헤더를 합친 PDU다. 최소 크기는 46바이트, 최대 크기는 1500바이트다. 46바이트 미만이라면 길이를 맞추기 위해 `패딩 (padding)`을 수행한다. FCS는 수신한 이더넷 프레임에 오류가 있는지 확인하기 위한 필드다. 이 필드에는 `CRC (cyclic redundancy check)`라는 오류 검출용 값이 들어간다. 송신지는 프리앰블을 제외한 나머지 필드 값들을 바탕으로 CRC 값을 계산한 후, 이 값을 FCS 필드에 명시한다. 수신자는 수신한 프레임에서 프리앰블과 FCS 필드를 제외한 나머지 필드 값들을 바탕으로 CRC 값을 계산한 뒤, 이 값을 FCS 필드 값과 비교한다. 이때 비교 값이 일치하지 않으면 프레임에 오류가 있다고 판단하여 해당 프레임을 폐기한다.

## 5. Spring

## 6. Database

## 7. JPA

## 8. Methodology

- [자바스크립트는 `프로토타입` 기반의 객체지향 언어](https://yozm.wishket.com/magazine/detail/1396/): 자바스크립트는 클래스가 없는 함수형 언어를 기반으로 하지만 객체지향 프로그래밍 맛을 느낄 수 있는 언어다. 자바스크립트는 클래스가 존재하지 않고 오직 객체만이 존재했었다. 과거형인 이유는 ES6에 오면서 클래스가 정식 문법이 되었기 때문이다. 물론 ES6의 클래스는 프로토타입 방식을 문법적으로 클래스처럼 보이게 해준 것이다. 다시 본론으로 돌아와서 오직 객체만이 존재했던 시절의 자바스크립트는 상속을 객체 간의 위임 (delegation) 메커니즘으로 구현하였다. 여기에서 깨달을 수 있는 사실은 객체지향의 핵심이 클래스가 아니라는 점이다. 핵심은 적절한 책임을 수행하는 역할 간의 유연하고 견고한 협력 관계를 구축하는 것이다. 클래스는 협력에 참여하는 객체를 만드는 데 필요한 구현 메커니즘일 뿐이다. 클래스도 중요하긴 하지만 협력 구조와 책임을 식별하는 것에 비해 상대적으로 덜 중요하다. 객체지향의 중심에는 클래스가 아니라 객체가 위치하며, 중요한 것은 클래스들의 정적인 관계가 아니라 메시지를 주고받는 객체들의 동적인 관계다.

## 9. Infrastructure

- [`표준 스트림`과 `표준 입출력`](https://shoark7.github.io/programming/knowledge/what-is-standard-stream): `표준 스트림`은 프로그램과 그 환경 사이에 미리 연결된 입출력 채널을 의미한다. 유닉스는 하드웨어별로 입출력을 위한 설정 작업을 따로 하는 문제를 해결하기 위해 입출력 작업을 파일을 읽고 쓰는 한 가지 작업으로 통일시켰다. 그리고 그 파일에서 읽히고 나가는 데이터를 스트림이라고 정의했다. 일반적으로 프로그램은 입출력을 필요로 하는데 입력과 출력이 특정 대상로부터만 발생한다면 사용자가 지정하지 않는 이상 기본적으로 사용할 입출력 대상을 설정해놓을 수 있으면 좋을 것이다. 그래서 한 프로그램이 기본적으로 사용할 입출력 대상을 `표준 입출력`이라고 한다. 살짝 애매하지만 표준 스트림과 표준 입출력은 똑같은 의미라고 봐도 될 것 같다.

- [쉘의 `I/O Redirection`](https://shoark7.github.io/programming/shell-programming/IO-Redirection-in-Shell): 쉘을 다룰 때 대부분의 명령어는 결과를 콘솔에 출력한다. 따로 지정하지 않았거나 못했기 때문에 표준 출력인 콘솔에 내놓은 것이다. 그런데 쉘을 종료하면 사라지는 콘솔에 출력시키는 것이 아니라 영구적으로 파일에 저장하고 싶을 수 있다. 그럴 때 사용하는 것이 `I/O Redirection`이다. 서버 로그를 남길 때 콘솔에 출력하는 것이 아니라 별도의 파일에 저장하는 것을 생각해보면 된다.
